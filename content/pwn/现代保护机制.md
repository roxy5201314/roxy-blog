---
title: "现代保护机制"
excerpt: "魔高一尺，道高一丈，攻防也是如此，有攻亦有防"
date: "2025-12-09"
slug: "protection"
section: "pwn"
---

<div class="intro-article">

上一篇我们实现了简单的overflow以hijack程序执行流

但是:

<span style="color:#845ef7">真的就这么简单吗?</span>

显然不是😄😄

还记得上一篇编译时的这个语句吗

> gcc -g -fno-stack-protector -z execstack -no-pie ezoverflow.c -o ezoverflow

为了方便演示，这条语句实际上关闭了许多程序保护措施

现在就让我们一个一个来看看为了防护二进制漏洞

# <span style="color:#845ef7">现代防御系统都存在着哪些机制</span>

## 1.-fno-stack-protector

> 关闭栈保护(**Canary**)

历史来源:

Canary的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。

工人们每次下井都会带上一只金丝雀。

如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。

在正常编译下

默认情况下，gcc会在函数栈帧中插入一个随机值(Canary)：

| buf[32] |
| Canary  |  ← 你一旦覆盖它
| saved rbp |
| ret addr |

函数返回前会检查：

if (canary != original_canary)

    __stack_chk_fail();

如果你溢出了？

程序会直接：

*** stack smashing detected! ***

Aborted (core dumped)

而这个参数完全关闭了栈Canary

因此实际的溢出并没有那么简单

你可能需要先

**泄露Canary**(格式化字符串漏洞,逻辑泄露)

或绕过Canary(SROP/partial overwrite/logic bug...)

## 2.-z execstack

> 栈可执行(关闭NX(non executable,windows中叫DEP))

如果NX开启,你在栈上放shellcode,然后跳过去：

Segmentation fault(段错误!)

这个参数使得栈是可执行的

这意味着shellcode可以直接写在栈上

极大地简化了利用流程

大多数情况NX都是开启的

这时候便需要

ROP技术(return oriented programming)

后续再展开吧...😂

## 3.-no-pie

> 关闭PIE(地址随机化)

PIE(Position Independent Executable)配合ASLR：

程序基址每次运行都不同

函数地址、gadgets地址全变

这个参数关闭了PIE,使得程序地址固定

依旧极大地简化了攻击流程

破解思路:

- 泄露程序基址(ret2libc)

- 利用GOT/PLT

- 利用已知偏移...

这些保护默认本是默认开启的

而我们这条命令相当于刻意把程序“退化”到十几年前的安全水平😂😂

因此pwn之路任重而道远啊...

> ps:利用checksec可以清楚地看到开启or关闭了哪些保护

that is end~🥰

感谢阅读!🥰

</div>