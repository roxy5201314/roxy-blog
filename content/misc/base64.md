---
title: "Base64 是什么？"
excerpt: "不是加密，是编码，但它在 CTF 里无处不在"
date: "2025-12-09"
slug: "base64"
section: "misc"
---

<div class="intro-article">

## Base64 是什么？

关键:

> **Base64 不是加密，它只是编码。**

它的作用非常朴素：  
👉 **把任意二进制数据，用“可打印字符”表示出来。**

---

## 为什么需要 Base64？

计算机中的数据本质是 **二进制 0 / 1**，  
但很多场景 **不适合直接传二进制**，比如：

- URL 参数
- HTTP 表单
- JSON / XML
- 邮件（SMTP）
- 一些只允许 ASCII 的系统

于是就需要把：

> **二进制 → 可打印字符**

Base64 就是为这个而生的。

---

## Base64 的字符集

Base64 一共使用 **64 个字符**：

ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
0123456789+/

再加一个特殊的填充符号：

=

---

## Base64 在“数学上”做了什么？

核心思想其实很简单：

- 每 **3 个字节 = 24 bit**
- 每 **6 bit 一组**
- 24 bit ÷ 6 bit = **4 组**
- 每组 6 bit → 映射成一个 Base64 字符

也就是：

> **3 字节 → 4 个 Base64 字符**

---

## 一个直观例子

字符串：

Man

对应 ASCII（二进制）：

M -> 01001101
a -> 01100001
n -> 01101110

拼起来（24 bit）：

010011010110000101101110

每 6 bit 分组：

010011 010110 000101 101110

转成十进制：

19 22 5 46

查 Base64 表：

T W F u

✅ 结果：

Man → TWFu

---

## 为什么会有 `=` 填充符？

如果原始数据 **不是 3 的倍数**：

- 剩 2 字节 → 补 1 个 `=`
- 剩 1 字节 → 补 2 个 `=`

作用只有一个：

> **凑够 4 字符一组**

举例：

Ma → TWE=
M → TQ==

---

## 在 CTF 中 Base64 的常见出现形式

### ✅ 1️⃣ 最简单：一眼 Base64

特征非常明显：

- 只包含 `A–Z a–z 0–9 + / =`
- 长度通常是 4 的倍数

例如：

ZmxhZ3tqdXN0X2RlY29kZX0=

👉 解码一下：

flag{just_decode}😎😎😎

---

### ✅ 2️⃣ 套娃型 Base64

CTF 里非常常见：

Base64 → Base64 → Base64 → 明文
甚至会出现：

偷偷换行

去掉 =

混一点别的字符

倒序

这种时候AI就不管用了，AI小哥哥只会暴力破解

你需要自己根据已知的flag形式去深入分析可能存在的变化

所以理解原理是十分必要的

要善于利用AI，但不能完全依赖AI而丧失自主的思考

✅ 3️⃣ 和其他编码一起出现
例如：

Base64 + URL 编码

Base64 + XOR(异或)

Base大家族(91,58,85,100)😷

看到 Base64 不要以为结束了，
它往往只是“外壳”。

常用工具

LINUX命令行

echo "TWFu" | base64 -d

Python（CTF 最常用）

import base64

s = "TWFu"
print(base64.b64decode(s).decode())

CyberChef（强烈推荐）😎

自动识别

可链式操作

非常适合套娃编码

**一个 CTF 重要提醒** ⚠️
Base64 ≠ 密码学安全

任何能看到密文的人：

都可以直接解码

不需要密钥

不需要破解

所以在 CTF 中它更多是：

✅ 迷惑
✅ 外壳
✅ 编码链的一环

小结 ✅
Base64 不是加密，只是编码

作用是把二进制变成可打印字符

CTF 中极常见，经常是第一步!

over~ 😎

感谢阅读!😎
</div>